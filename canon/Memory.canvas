{
	"nodes":[
		{"id":"9a955ae4bdcee4fe","type":"file","file":"A_GIT_PROJECTS/Agents/Quantum_Harmony_OS/Quantum_harmony_Agent_Card.md.md","x":-5431,"y":-4020,"width":601,"height":460,"color":"1"},
		{"id":"a6d4a767c7331730","type":"file","file":"A_GIT_PROJECTS/Agents/Artemis/Artemis Transmission Protocol (ATP).md","x":-6360,"y":-3856,"width":330,"height":378,"color":"1"},
		{"id":"330c6fcc4ebd6417","type":"file","file":"A_GIT_PROJECTS/Chat_Logs/MSFT_Defense.md","x":-6280,"y":-4347,"width":380,"height":327},
		{"id":"0d9349941e65fe78","type":"file","file":"A_GIT_PROJECTS/Chat_Logs/Quantum_Harmony_Pt1.md","x":-4000,"y":-5580,"width":980,"height":480},
		{"id":"9488c3e1ab80ec90","type":"file","file":"A_GIT_PROJECTS/Chat_Logs/Project_Strt.md","x":-6600,"y":-5940,"width":1020,"height":360},
		{"id":"5b1caa0d1ded4d84","type":"file","file":"A_GIT_PROJECTS/Chat_Logs/Monday_Chat.md","x":-5580,"y":-5178,"width":600,"height":300,"color":"1"},
		{"id":"3894a4b3df9b42c6","type":"text","text":"COmpSuiteFin\n","x":-2640,"y":-5940,"width":295,"height":463,"color":"3"},
		{"id":"7e6d2d1591dbd6b4","type":"file","file":"Fin_lit_AppChat.md","x":-3870,"y":-4659,"width":610,"height":476,"color":"6"},
		{"id":"82dd36f68349e7c6","type":"text","text":"\n\n---\ntitle: \"Quantum Harmony: Part 1 – R Environment & Visualization Setup\"\nauthor: \"Artemis + Learner Co-Development\"\nproject: \"Quantum Harmony\"\nfile_part: \"Part 1 - R\"\natp_protocol: \"active\"\natp_node: \"qh.learn.01.r\"\n ---\n #R   #SemanticLogic #ATP_Learn \n # Part1\n\n\n## Introduction\nWelcome to Part 1 of Quantum Harmony. This section is focused on setting up your R-based learning environment and introducing the visual logic we’ll use throughout. You’ll be engaging in data wrangling and creating your first semantic visualizations.\n\nThis isn’t just technical setup—it’s cognitive. You're building both the *space* and *practice* for future analytical reasoning.\n\n\n## Step 1: Load the Data\n```{r}\nlibrary(tidyverse)\nlibrary(lubridate)\n\nsales_data <- read_csv(\"quantum_sales_data.csv\")\nglimpse(sales_data)\n```\n\n### ATP Checkpoint\n```{r}\n#| atp: \"qh.learn.r.chk001\"\n# Observe the structure: What dimensions are implied (region, product, time)?\n# What assumptions might already exist in the column naming?\n```\n\n**Output Expectation:**\nYou should see a preview of the dataset's structure—columns like Date, Region, Product, Sales. Confirm no missing values and understand the type of each column.\n\n\n## Step 2: Monthly Aggregation\n```{r}\nsales_summary <- sales_data %>%\n  mutate(Month = floor_date(Date, unit = \"month\")) %>%\n  group_by(Month, Product) %>%\n  summarise(Total_Sales = sum(Sales), .groups = \"drop\")\n```\n\n### ATP Context Tag\n```{r}\n#| atp: \"qh.learn.r.chk002\"\n# Why monthly? What might be hidden if we grouped by week or quarter?\n```\n\n**Output Expectation:**\nThis step produces a summarized data frame. Expect ~24–36 rows (depending on product count and timeline) with columns for Month, Product, and Total_Sales.\n\n\n## Step 3: Visualize Your Data\n```{r}\nggplot(sales_summary, aes(Month, Total_Sales, color = Product)) +\n  geom_line() +\n  labs(title = \"Monthly Sales by Product\") +\n  theme_minimal()\n```\n\n### ATP Reflection Unit\n```{r}\n#| atp: \"qh.learn.r.viz001\"\n# This visualization encodes both temporal trend and categorical differentiation.\n# What patterns jump out? Is the top performer consistent? Are any seasonal effects visible?\n```\n\n**Output Expectation:**\nYou should see a line chart with multiple colored lines—each one representing a product’s sales over time. Peaks, troughs, and crossovers should be visible.\n\n\n## Challenge 1: Portfolio Debug\n**Task:**\nUsing the visual above, identify:\n- Which product shows the highest volatility?\n- Which product appears to have cyclical trends?\n\n**Expected Thought Process:**\nLook for fluctuations (amplitude of ups/downs) and repeating patterns that align with calendar intervals (monthly, seasonal).\n\n**Hint:** Hover your cursor over chart points in Quarto preview. This interactivity is key to how semantic visuals communicate multiple layers.\n\n**Output Expectation:**\nNo code output, but reflection is required. Jot down or comment which product you think is the most volatile and why.\n\n\n## ATP Closeout: Reflection Node\n```markdown\n::: {.callout-tip}\n### ATP Node `qh.learn.r.chk999`\nThis section was about more than syntax.\nYou’ve set up your environment, mapped temporal relationships, and created an early-stage visualization sandbox. From here forward, every tool builds on this foundation.\n:::\n```\n\nReady to proceed to Power Query in Part 2?\nLet’s move from aggregation to transformation.\n---\ntitle: \"Quantum Harmony: Part 2 – Power Query M & Schema Structuring\"\nauthor: \"Artemis + Learner Co-Development\"\nproject: \"Quantum Harmony\"\nfile_part: \"Part 2 - M\"\natp_protocol: \"active\"\natp_node: \"qh.learn.02.m\"\ntags: [\"#PowerQuery\", \"#ATP_Learn\", \"#Schema\", \"#Part2\"]\n---\n\n## Introduction\nThis section explores Power Query M language as your structural layer. You’ll transform and prepare your dataset within Power BI, mirroring what data engineers call the “staging phase.”\n\nM is declarative. That means each step is a transformation upon the last, forming a logical pipeline.\n\n\n## Step 1: Load Excel Data into Power BI\n```{m}\n#| label: m_load_source\n#| atp: \"qh.learn.m.chk001\"\nlet\n    Source = Excel.Workbook(File.Contents(\"quantum_sales_data.xlsx\")),\n    SalesSheet = Source{[Name=\"Sales\"]}[Content]\nin\n    SalesSheet\n```\n\n**Output Expectation:**\nReturns a raw table with possible generic column names. You should verify that the first row contains the actual column headers.\n\n\n## Step 2: Promote Headers\n```{m}\n#| label: m_promote_headers\n#| atp: \"qh.learn.m.chk002\"\nlet\n    PromotedHeaders = Table.PromoteHeaders(SalesSheet)\nin\n    PromotedHeaders\n```\n\n**Output Expectation:**\nYour columns should now read as `Date`, `Region`, `Product`, `Sales`. Confirm readable formatting.\n\n\n## Step 3: Type Declaration\n```{m}\n#| label: m_type_transform\n#| atp: \"qh.learn.m.chk003\"\nlet\n    ChangedTypes = Table.TransformColumnTypes(PromotedHeaders, {\n        {\"Date\", type date},\n        {\"Region\", type text},\n        {\"Product\", type text},\n        {\"Sales\", type number}\n    })\nin\n    ChangedTypes\n```\n\n**Output Expectation:**\nTyped table output. Power BI should now display proper aggregation options (e.g., SUM for Sales).\n\n\n## Step 4: Add Year and Month Columns\n```{m}\n#| label: m_derive_fields\n#| atp: \"qh.learn.m.chk004\"\nlet\n    WithDateParts = Table.AddColumn(ChangedTypes, \"Year\", each Date.Year([Date]), Int64.Type),\n    WithMonth = Table.AddColumn(WithDateParts, \"Month\", each Date.Month([Date]), Int64.Type)\nin\n    WithMonth\n```\n\n**Output Expectation:**\nExpect 2 new columns—Year and Month—appearing in your table. This enables easier filtering and grouping.\n\n\n## ATP Challenge: Error Handling In M\n```markdown\n::: {.callout-tip}\n### Task: Introduce a Safety Check\nAdd a step that checks if the `Sales` column contains nulls and fills them with 0.\n\n**Hint:** Use `Table.TransformColumns` or `Table.ReplaceValue`.\n:::\n```\n\n\n## ATP Closeout\n```markdown\n::: {.callout-note}\n### ATP Node `qh.learn.m.chk999`\nPower Query is your structural brush. By controlling the types, headers, and derived fields, you define what the model layer *means*.\nNext up: we model that logic semantically with DAX.\n:::\n```\n\nReady to model this logic with DAX? Let’s move to Part 3.\n\n\n---\ntitle: \"Quantum Harmony: Part 3 – DAX Modeling and Semantic Logic\"\nauthor: \"Artemis + Learner Co-Development\"\nproject: \"Quantum Harmony\"\nfile_part: \"Part 3 - DAX\"\natp_protocol: \"active\"\natp_node: \"qh.learn.03.dax\"\ntags: [\"#DAX\", \"#SemanticLogic\", \"#ATP_Learn\", \"#Part3\"]\n---\n\n## Introduction\nPart 3 of Quantum Harmony transitions us into the modeling layer. Here, we use DAX (Data Analysis Expressions) to define logic that shapes insights.\n\nYou’re not just calculating metrics—you’re encoding relationships between filters, time, and categories.\n\n\n## Step 1: Base Measures\n```dax\nTotal Sales = SUM(Sales[Sales])\n```\n\n### ATP Checkpoint\n```dax\n--| atp: \"qh.learn.dax.chk001\"\n-- What assumption does this measure carry about granularity and aggregation context?\n```\n\n**Output Expectation:**\nA basic measure visible in Power BI visuals. Confirm numeric format and correct totals across filters.\n\n\n## Step 2: Time Intelligence\n```dax\nSales LY = CALCULATE([Total Sales], SAMEPERIODLASTYEAR('Date'[Date]))\n```\n\n```dax\nSales YoY = [Total Sales] - [Sales LY]\n```\n\n### ATP Context\n```dax\n--| atp: \"qh.learn.dax.chk002\"\n-- How does SAMEPERIODLASTYEAR differ from shifting by 365 days?\n-- What breaks when the calendar table is incomplete?\n```\n\n**Output Expectation:**\nYou should see time-based comparisons in line charts or KPIs. Line crossings will reflect business cycles.\n\n\n## Step 3: Comparative Measures\n```dax\n% of Total = \nDIVIDE(\n    [Total Sales], \n    CALCULATE([Total Sales], ALL('Product'))\n)\n```\n\n### ATP Semantic Layer Prompt\n```dax\n--| atp: \"qh.learn.dax.chk003\"\n-- What does removing filters using ALL() imply about scope and fairness of comparison?\n```\n\n**Output Expectation:**\nEach product's share as a percentage. Can be visualized in bar or pie charts.\n\n\n## Challenge: Peer Ranking\n**Task:**\nCreate a measure to rank products by total sales.\n\n**Hint:** Use `RANKX` and consider how ties and order direction affect readability.\n\n**ATP Addendum:**\nIs this rank **static** or **dynamic** depending on slicers and filters?\n\n\n## ATP Closeout\n```markdown\n::: {.callout-tip}\n### ATP Node `qh.learn.dax.chk999`\nDAX transforms numbers into meaning. Each calculation is a semantic contract. Part 3 trained you to model context-aware logic.\nNext: let’s model the future with Python forecasting.\n:::\n```\n\nReady for the final stretch? Let’s forecast Part 4.\n\n\n---\ntitle: \"Quantum Harmony: Part 4 – Python Forecasting and Future Modeling\"\nauthor: \"Artemis + Learner Co-Development\"\nproject: \"Quantum Harmony\"\nfile_part: \"Part 4 - Python\"\natp_protocol: \"active\"\natp_node: \"qh.learn.04.py\"\ntags: [\"#Python\", \"#Forecasting\", \"#ATP_Learn\", \"#Part4\"]\n---\n\n## Introduction\nIn this final part of the Quantum Harmony learn series, we forecast the future using Python. We'll apply linear modeling techniques to project trends and build interpretive visuals.\n\nYou’ve wrangled, structured, and modeled. Now we simulate forward.\n\n\n## Step 1: Load Data & Setup\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\n\n# Load your data\nsales = pd.read_csv(\"quantum_sales_data.csv\")\nsales['Date'] = pd.to_datetime(sales['Date'])\nsales['Month'] = sales['Date'].dt.to_period('M')\nsales_summary = sales.groupby(['Month']).agg({'Sales':'sum'}).reset_index()\nsales_summary['Month_Num'] = range(len(sales_summary))\n```\n\n**Output Expectation:**\nTime-aggregated sales data and a `Month_Num` index for regression. Ready for training.\n\n\n## Step 2: Train Model\n```python\nX = sales_summary[['Month_Num']]\ny = sales_summary['Sales']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n```\n\n**Output Expectation:**\nLinear model trained on time vs sales.\n\n\n## Step 3: Predict & Evaluate\n```python\ny_pred = model.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)\nprint(\"Test MSE:\", mse)\n```\n\n### ATP Checkpoint\n```python\n#| atp: \"qh.learn.py.chk001\"\n# What does the MSE tell you about this model's bias or variance?\n```\n\n\n## Step 4: Visualize Forecast\n```python\nplt.figure(figsize=(10, 5))\nplt.plot(sales_summary['Month_Num'], sales_summary['Sales'], label='Actual')\nplt.plot(X_test['Month_Num'], y_pred, label='Forecast', linestyle='--')\nplt.legend()\nplt.title(\"Sales Forecast vs Actual\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Sales\")\nplt.show()\n```\n\n**Output Expectation:**\nLine graph comparing actual to forecasted sales. Evaluate gap and alignment visually.\n\n\n## ATP Challenge\nAdd a confidence interval band around the forecast using `statsmodels` or prediction intervals.\n\n\n## ATP Closeout\n```markdown\n::: {.callout-tip}\n### ATP Node `qh.learn.py.chk999`\nPython reveals not just what happened—but what might. You’ve now completed the learn series, spanning R, M, DAX, and Python with ATP reflection.\nTime to integrate these into your next mission.\n:::\n```\n\nCongratulations, semantic modeler. You’ve closed the loop.\n","x":-2160,"y":-4347,"width":480,"height":280,"color":"3"},
		{"id":"e7300707d969481f","type":"file","file":"A_GIT_PROJECTS/Chat_Logs/Quantum_learn_Steps_Python.md","x":-2825,"y":-4878,"width":480,"height":370,"color":"5"},
		{"id":"eafcaa5fbf4a83b4","type":"file","file":"FIn_Lit_Iteration1.md","x":-4760,"y":-4523,"width":660,"height":340,"color":"6"},
		{"id":"5b70a1e3ae96f48e","type":"text","text":"Windows_Log Monitor ","x":-2725,"y":-3440,"width":380,"height":320},
		{"id":"911b7b82f9e6cbdb","type":"text","text":"Azure Interjection","x":-3870,"y":-3696,"width":490,"height":576},
		{"id":"303a0d0ee2015fc5","type":"text","text":"Copilot and Codex to scaffold faster\n","x":-4080,"y":-2600,"width":508,"height":389},
		{"id":"2eda1892f2704837","type":"text","text":"PythonConverter\n\nHandwrotognjson is easiest way to do it \n","x":-5172,"y":-3120,"width":342,"height":301},
		{"id":"d00d980862176cdc","type":"text","text":"ArtemisAgent","x":-6727,"y":-4941,"width":367,"height":497,"color":"3"}
	],
	"edges":[
		{"id":"8bfd68092436170b","fromNode":"9488c3e1ab80ec90","fromSide":"right","toNode":"0d9349941e65fe78","toSide":"top"},
		{"id":"559c0ceebfe80464","fromNode":"0d9349941e65fe78","fromSide":"left","toNode":"5b1caa0d1ded4d84","toSide":"right"},
		{"id":"a681382dacf3ba6a","fromNode":"5b1caa0d1ded4d84","fromSide":"bottom","toNode":"330c6fcc4ebd6417","toSide":"top"},
		{"id":"301494d211c04e58","fromNode":"9488c3e1ab80ec90","fromSide":"bottom","toNode":"5b1caa0d1ded4d84","toSide":"top"},
		{"id":"b6a6e1c7610b22a7","fromNode":"5b1caa0d1ded4d84","fromSide":"bottom","toNode":"9a955ae4bdcee4fe","toSide":"top"},
		{"id":"36c048b1d98ebe8f","fromNode":"0d9349941e65fe78","fromSide":"bottom","toNode":"e7300707d969481f","toSide":"top"},
		{"id":"34d08da2e8a6167b","fromNode":"7e6d2d1591dbd6b4","fromSide":"left","toNode":"eafcaa5fbf4a83b4","toSide":"top"},
		{"id":"93ddde495f797912","fromNode":"5b1caa0d1ded4d84","fromSide":"bottom","toNode":"a6d4a767c7331730","toSide":"top"},
		{"id":"db592df1aea25cee","fromNode":"0d9349941e65fe78","fromSide":"bottom","toNode":"7e6d2d1591dbd6b4","toSide":"top"},
		{"id":"7dc831edddb8b115","fromNode":"e7300707d969481f","fromSide":"right","toNode":"82dd36f68349e7c6","toSide":"top"},
		{"id":"1a3894e2f0b9f296","fromNode":"0d9349941e65fe78","fromSide":"top","toNode":"3894a4b3df9b42c6","toSide":"top","color":"3"},
		{"id":"f5b331caedbec39a","fromNode":"5b1caa0d1ded4d84","fromSide":"left","toNode":"d00d980862176cdc","toSide":"top","color":"3"},
		{"id":"f289685932acd4d1","fromNode":"e7300707d969481f","fromSide":"left","toNode":"5b70a1e3ae96f48e","toSide":"right"},
		{"id":"446d8c135ad592c6","fromNode":"7e6d2d1591dbd6b4","fromSide":"right","toNode":"5b70a1e3ae96f48e","toSide":"top"},
		{"id":"0c0e0242e5931c78","fromNode":"7e6d2d1591dbd6b4","fromSide":"bottom","toNode":"911b7b82f9e6cbdb","toSide":"top"},
		{"id":"03ee3c30f475612e","fromNode":"5b70a1e3ae96f48e","fromSide":"bottom","toNode":"911b7b82f9e6cbdb","toSide":"right"},
		{"id":"610c068f8e5ceb66","fromNode":"911b7b82f9e6cbdb","fromSide":"left","toNode":"303a0d0ee2015fc5","toSide":"top"},
		{"id":"f84f57c80b86f372","fromNode":"eafcaa5fbf4a83b4","fromSide":"bottom","toNode":"2eda1892f2704837","toSide":"right"},
		{"id":"f7fdd3cd53df0983","fromNode":"303a0d0ee2015fc5","fromSide":"left","toNode":"2eda1892f2704837","toSide":"right"}
	]
}